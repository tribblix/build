Maintain the existing Solaris libXt ABI, by setting the library so-version to 4
(libXt.so.4) and using the mapfile to control & version exported symbols.

Not suitable for upstream.

--- libXt-1.1.5/src/Makefile.am
+++ libXt-1.1.5/src/Makefile.am
@@ -74,7 +74,8 @@ DISTCLEANFILES = StringDefs.c
 
 libXt_la_LIBADD = @XT_LIBS@
 
-libXt_la_LDFLAGS = -version-number 6:0:0 -no-undefined
+libXt_la_LDFLAGS = -version-number 4:0:0 -no-undefined \
+	-Wl,-M,$(top_srcdir)/mapfile-vers -lc
 
 #
 # The util directory contains a program that builds some of the sources.
Fix for Oracle Bug 15077293 - SUNBT4497193 Motif does not cache ref-counted
    objects correctly

Unclear if we still need this or if it should be sent upstream - need to
check if our Motif build relies on this or not.

Root Cause:
When libXt caches ref counted objects, it keeps the same handle as is kept in
the widget. When the widget then releases the handle, the underlying object may
be freed if its ref count goes to 0. This invalidates the cached value.
Examples of ref-counted objects are "XmRendition"s and "XmRenderTable"s.

Description:
The cacheing code in Convert.c has to be made aware of objects that are
externally ref-counted, because the "thing" that gets cached is one of any
number of handles out on the underlying object. It therefore means that, before
the handle get stored in the cache, it has to be replicated, since the original
handle belongs to the widget that originally did the call to get the resource.
Likewise, when another widget tries to get the same resource, the cached handle
has to be replicated to provide the calling widget with its own handle.

In order to do this I provided a new cacheing flag: XtCacheXmRefCount. When this
is detected, the cacheing routines will do the appropriate replication. Since
a replicator function is not provided for in the exiting API, I added a new
call: _XtSetTypeConverter() - an enhancement of XtSetTypeConverter(). This new
function, _XtSetTypeConverter(), underlies the original XtSetTypeConverter().
Underlying the original XtSetTypeConverter() was a function called
_XtTableAddConverter(). This has also been rebuilt on top of a new function,
TableAddConverter(), which handles replicators.

I made one more significant change in order to simplify the code. This was to
eliminate the converter extension structure, and incorporate it into the
converter structure. Three effects of this change:

 1.     There may be a slight change in memory usage, but I could not
        detect anything in my tests.
 2.     Handling of the structures is faster EXCEPT
 3.     in calls to XtCallbackReleaseCacheRef(), where in the old code
        a converter could be removed from the linked list through its
        "prev" extension member, a linear search is done in the appropriate
        hash chain. I could detect no degradation in performance.

Note that the change could have been done more simply if _XtTableAddConverter()
were not already an exported interface, because it could then simply have been
enhanced without the creation of TableAddConverter().

--- a/include/X11/Intrinsic.h	2022-11-07 12:17:01.624802131 -0800
+++ b/include/X11/Intrinsic.h	2022-11-07 12:26:00.376664222 -0800
@@ -134,6 +134,7 @@
 #define			XtCacheAll	  0x002
 #define			XtCacheByDisplay  0x003
 #define			XtCacheRefCount	  0x100
+#define			XtCacheXmRefCount 0x200
 
 /****************************************************************
  *
@@ -256,6 +257,8 @@
     Cardinal*		/* num_args */
 );
 
+typedef XtPointer (*XtReplicator)(XtPointer);
+
 typedef Opaque XtCacheRef;
 
 typedef Opaque XtActionHookId;
@@ -659,6 +662,17 @@
     XtDestructor 	/* destructor */
 );
 
+extern void _XtSetTypeConverter(
+    _Xconst _XtString   /* from_type */,
+    _Xconst _XtString   /* to_type */,
+    XtTypeConverter     /* converter */,
+    XtConvertArgList    /* convert_args */,
+    Cardinal            /* num_args */,
+    XtCacheType         /* cache_type */,
+    XtDestructor        /* destructor */,
+    XtReplicator        /* replicator */
+);
+
 extern void XtAppSetTypeConverter(
     XtAppContext 	/* app_context */,
     _Xconst _XtString 	/* from_type */,
--- a/src/Convert.c	2022-11-08 17:05:15.492789475 -0800
+++ b/src/Convert.c	2022-11-08 17:25:27.254721387 -0800
@@ -88,6 +88,7 @@
     XrmRepresentation from, to;
     XtTypeConverter converter;
     XtDestructor destructor;
+    XtReplicator replicator;
     unsigned short num_args;
     unsigned int do_ref_count:1;
     unsigned int new_style:1;
@@ -100,6 +101,20 @@
 /* used for old-style type converter cache only */
 static Heap globalHeap = { NULL, NULL, 0 };
 
+static
+void TableAddConverter(
+    ConverterTable      table,
+    XrmRepresentation   from_type,
+    XrmRepresentation   to_type,
+    XtTypeConverter     converter,
+    XtConvertArgRec const* convert_args,
+    Cardinal            num_args,
+    _XtBoolean          new_style,
+    XtCacheType         cache_type,
+    XtDestructor        destructor,
+    XtReplicator        replicator,
+    _XtBoolean          global);
+
 void
 _XtSetDefaultConverterTable(ConverterTable *table)
 {
@@ -119,13 +134,11 @@
 
         for (i = CONVERTHASHSIZE; --i >= 0;) {
             for (rec = *globalConverterTable++; rec; rec = rec->next) {
-                cache_type = rec->cache_type;
-                if (rec->do_ref_count)
-                    cache_type |= XtCacheRefCount;
-                _XtTableAddConverter(*table, rec->from, rec->to, rec->converter,
+                cache_type = rec->cache_type | (rec->do_ref_count & 0xff00);
+                TableAddConverter(*table, rec->from, rec->to, rec->converter,
                                      ConvertArgs(rec), rec->num_args,
                                      rec->new_style, cache_type,
-                                     rec->destructor, True);
+                                     rec->destructor, rec->replicator, True);
             }
         }
     }
@@ -158,10 +171,14 @@
     XtPointer tag;
     int hash;
     XtTypeConverter converter;
+    XtDestructor destructor;
+    XtReplicator replicator;
+    XtPointer closure;
     unsigned short num_args;
     unsigned int conversion_succeeded:1;
     unsigned int has_ext:1;
     unsigned int is_refcounted:1;
+    unsigned int ref_count;
     unsigned int must_be_freed:1;
     unsigned int from_is_value:1;
     unsigned int to_is_value:1;
@@ -169,16 +186,8 @@
     XrmValue to;
 } CacheRec;
 
-typedef struct _CacheRecExt {
-    CachePtr *prev;
-    XtDestructor destructor;
-    XtPointer closure;
-    long ref_count;
-} CacheRecExt;
+#define CARGS(p) (XrmValue *)((p)+(ptrdiff_t)1)
 
-#define CEXT(p) ((CacheRecExt *)((p)+1))
-#define CARGS(p) ((p)->has_ext ? (XrmValue *)(CEXT(p)+1) : (XrmValue *)((p)+1))
-
 #define CACHEHASHSIZE   256
 #define CACHEHASHMASK   255
 typedef CachePtr CacheHashTable[CACHEHASHSIZE];
@@ -197,29 +206,51 @@
                      XtDestructor destructor,
                      _XtBoolean global)
 {
-    register ConverterPtr *pp;
-    register ConverterPtr p;
+    unsigned short     cache_flags;
+
+    cache_flags = cache_type & (XtCacheNone | XtCacheAll |
+                               XtCacheByDisplay | XtCacheRefCount);
+
+    TableAddConverter(table, from_type, to_type, converter, convert_args, num_args,
+                       new_style, cache_type, destructor, 0, global);
+}
+
+void TableAddConverter(
+    ConverterTable      table,
+    XrmRepresentation   from_type,
+    XrmRepresentation   to_type,
+    XtTypeConverter     converter,
+    XtConvertArgRec     const* convert_args,
+    Cardinal            num_args,
+    _XtBoolean          new_style,
+    XtCacheType         cache_type,
+    XtDestructor        destructor,
+    XtReplicator        replicator,
+    _XtBoolean          global)
+{
+    register ConverterPtr       *pp;
+    register ConverterPtr       p;
     XtConvertArgList args;
 
-    pp = &table[ProcHash(from_type, to_type) & CONVERTHASHMASK];
+    pp= &table[ProcHash(from_type, to_type) & CONVERTHASHMASK];
     while ((p = *pp) && (p->from != from_type || p->to != to_type))
         pp = &p->next;
 
     if (p) {
         *pp = p->next;
-        XtFree((char *) p);
+        XtFree((char *)p);
     }
 
-    p = (ConverterPtr) __XtMalloc((Cardinal) (sizeof(ConverterRec) +
-                                              sizeof(XtConvertArgRec) *
-                                              num_args));
-    p->next = *pp;
+    p = (ConverterPtr) __XtMalloc(sizeof(ConverterRec) +
+                                sizeof(XtConvertArgRec) * num_args);
+    p->next         = *pp;
     *pp = p;
-    p->from = from_type;
-    p->to = to_type;
-    p->converter = converter;
-    p->destructor = destructor;
-    p->num_args = (unsigned short) num_args;
+    p->from         = from_type;
+    p->to           = to_type;
+    p->converter    = converter;
+    p->destructor   = destructor;
+    p->replicator   = replicator;
+    p->num_args     = (unsigned short) num_args;
     XtSetBit(p->global, global);
 
     args = ConvertArgs(p);
@@ -228,23 +259,22 @@
     XtSetBit(p->new_style, new_style);
     p->do_ref_count = False;
     if (destructor || (cache_type & 0xff)) {
-        p->cache_type = (char) (cache_type & 0xff);
-        if (cache_type & XtCacheRefCount)
-            p->do_ref_count = True;
-    }
-    else {
+        p->cache_type = cache_type & 0xff;
+        p->do_ref_count = cache_type & 0xff00;
+    } else {
         p->cache_type = XtCacheNone;
     }
 }
 
 void
-XtSetTypeConverter(register _Xconst char *from_type,
+_XtSetTypeConverter(register _Xconst char *from_type,
                    register _Xconst char *to_type,
                    XtTypeConverter converter,
                    XtConvertArgList convert_args,
                    Cardinal num_args,
                    XtCacheType cache_type,
-                   XtDestructor destructor)
+                   XtDestructor destructor,
+		   XtReplicator replicator)
 {
     ProcessContext process;
     XtAppContext app;
@@ -261,18 +291,37 @@
         process->globalConverterTable = (ConverterTable)
             __XtCalloc(CONVERTHASHSIZE, (unsigned) sizeof(ConverterPtr));
     }
-    _XtTableAddConverter(process->globalConverterTable, from, to,
-                         converter, convert_args,
-                         num_args, True, cache_type, destructor, True);
+    TableAddConverter(process->globalConverterTable, from, to, converter,
+                         convert_args, num_args, True, cache_type, destructor,
+                         replicator, True);
     while (app) {
-        _XtTableAddConverter(app->converterTable, from, to,
-                             converter, convert_args,
-                             num_args, True, cache_type, destructor, True);
+        TableAddConverter(app->converterTable, from, to, converter,
+                             convert_args, num_args, True, cache_type,
+                             destructor, replicator, True);
         app = app->next;
     }
     UNLOCK_PROCESS;
 }
 
+void XtSetTypeConverter(
+    register _Xconst char* from_type,
+    register _Xconst char* to_type,
+    XtTypeConverter converter,
+    XtConvertArgList convert_args,
+    Cardinal num_args,
+    XtCacheType cache_type,
+    XtDestructor destructor
+    )
+{
+    unsigned short     cache_flags;
+
+    cache_flags = cache_type & (XtCacheNone | XtCacheAll |
+                               XtCacheByDisplay | XtCacheRefCount);
+
+    _XtSetTypeConverter(from_type, to_type, converter, convert_args, num_args,
+                       cache_flags, destructor, 0);
+}
+
 void
 XtAppSetTypeConverter(XtAppContext app,
                       register _Xconst char *from_type,
@@ -357,6 +406,7 @@
            Boolean do_ref,
            Boolean do_free,
            XtDestructor destructor,
+           XtReplicator replicator,
            XtPointer closure)
 {
     register CachePtr *pHashEntry;
@@ -365,23 +415,9 @@
     LOCK_PROCESS;
     pHashEntry = &cacheHashTable[hash & CACHEHASHMASK];
 
-    if ((succeeded && destructor) || do_ref) {
-        p = (CachePtr) _XtHeapAlloc(heap, (Cardinal) (sizeof(CacheRec) +
-                                                      sizeof(CacheRecExt) +
-                                                      num_args *
-                                                      sizeof(XrmValue)));
-        CEXT(p)->prev = pHashEntry;
-        CEXT(p)->destructor = succeeded ? destructor : NULL;
-        CEXT(p)->closure = closure;
-        CEXT(p)->ref_count = 1;
-        p->has_ext = True;
-    }
-    else {
-        p = (CachePtr) _XtHeapAlloc(heap, (Cardinal) (sizeof(CacheRec) +
-                                                      num_args *
-                                                      sizeof(XrmValue)));
-        p->has_ext = False;
-    }
+    p = (CachePtr)_XtHeapAlloc(heap,
+                       (sizeof(CacheRec) + num_args * sizeof(XrmValue)));
+
     if (!to->addr)
         succeeded = False;
     XtSetBit(p->conversion_succeeded, succeeded);
@@ -388,13 +424,14 @@
     XtSetBit(p->is_refcounted, do_ref);
     XtSetBit(p->must_be_freed, do_free);
     p->next = *pHashEntry;
-    if (p->next && p->next->has_ext)
-        CEXT(p->next)->prev = &p->next;
 
     *pHashEntry = p;
     p->tag = (XtPointer) heap;
     p->hash = hash;
     p->converter = converter;
+    p->destructor = destructor;
+    p->replicator = replicator;
+    p->closure = closure;
     p->from.size = from->size;
     if (from->size <= sizeof(p->from.addr)) {
         p->from_is_value = True;
@@ -487,17 +543,17 @@
 {
     int i;
     register CachePtr rec;
+    register CachePtr *next_link;
 
     LOCK_PROCESS;
     for (i = CACHEHASHSIZE; --i >= 0;) {
-        register CachePtr *prev = &cacheHashTable[i];
-
-        while ((rec = *prev)) {
+	next_link = &cacheHashTable[i];
+	while ((rec = *next_link)) {
+	    next_link = &rec->next;
             if (rec->tag == tag)
-                FreeCacheRec(app, rec, prev);
-            else
-                prev = &rec->next;
+		FreeCacheRec(app, rec, False);
         }
+	cacheHashTable[i] = 0;
     }
     UNLOCK_PROCESS;
 }
@@ -706,7 +762,7 @@
     {
         CacheEnter(&globalHeap, (XtTypeConverter) converter, args, num_args,
                    from, to, (to->addr != NULL), hash, False, False,
-                   (XtDestructor) NULL, NULL);
+                   (XtDestructor) NULL, NULL, 0);
     }
     UNLOCK_PROCESS;
 }
@@ -743,6 +799,7 @@
     CachePtr p;
     int hash;
     Boolean retval;
+    XPointer from_addr, gptr;
 
     if (!cP || ((cP->cache_type == XtCacheNone) && !cP->destructor)) {
         XtPointer closure;
@@ -799,14 +856,18 @@
                                 UNLOCK_PROCESS;
                                 return False;
                             }
-                            to->size = p->to.size;
-                            if (p->to_is_value) {
-                                XtMemmove(to->addr, &p->to.addr, to->size);
+                            if (cP->do_ref_count & XtCacheXmRefCount) {
+                               gptr = (*(p->replicator))(p->to.addr);
+                               from_addr = (XPointer)&gptr;
+                            } else if (p->to_is_value) {
+                                from_addr = (XPointer)&p->to.addr;
                             }
                             else {
-                                (void) memmove((char *) to->addr,
-                                               (char *) p->to.addr, to->size);
+				from_addr = p->to.addr;
                             }
+			    to->size = p->to.size;
+			    memmove((char *)to->addr, from_addr,
+				to->size);
                         }
                         else {  /* old-style call */
                             to->size = p->to.size;
@@ -817,7 +878,7 @@
                         }
                     }
                     if (p->is_refcounted) {
-                        CEXT(p)->ref_count++;
+                        p->ref_count++;
                         if (cache_ref_return)
                             *cache_ref_return = (XtCacheRef) p;
                         else
@@ -840,7 +901,7 @@
         Heap *heap;
         XtPointer closure = NULL;
         unsigned int supplied_size = to->size;
-        Boolean do_ref = cP->do_ref_count && cache_ref_return;
+        unsigned short do_ref;
         Boolean do_free = False;
 
         retval =
@@ -855,6 +916,8 @@
             return False;
         }
 
+	do_ref = cache_ref_return ? cP->do_ref_count : 0;
+
         if ((cP->cache_type == XtCacheNone) || do_ref) {
             heap = NULL;
             do_free = True;
@@ -866,8 +929,12 @@
         else
             heap = &XtDisplayToApplicationContext(dpy)->heap;
 
-        p = CacheEnter(heap, converter, args, num_args, from, to, retval,
-                       hash, do_ref, do_free, cP->destructor, closure);
+        if (do_ref || !(cP->do_ref_count & XtCacheXmRefCount)) {
+               p = CacheEnter(heap, converter, args, num_args, from, to, retval,
+                      hash, do_ref, do_free, cP->destructor,
+                      cP->replicator, closure);
+        }
+
         if (do_ref)
             *cache_ref_return = (XtCacheRef) p;
         else if (cache_ref_return)
@@ -1103,8 +1170,8 @@
     LOCK_APP(app);
     LOCK_PROCESS;
     for (r = (CachePtr *) refs; (p = *r); r++) {
-        if (p->is_refcounted && --(CEXT(p)->ref_count) == 0) {
-            FreeCacheRec(app, p, NULL);
+        if (p->is_refcounted && (--p->ref_count) == 0) {
+            FreeCacheRec(app, p, True);
         }
     }
     UNLOCK_PROCESS;
--- a/src/Convert.c	2024-08-23 17:09:07.282194470 -0700
+++ b/src/Convert.c	2024-08-23 17:13:15.389361355 -0700
@@ -458,48 +458,68 @@
         p->to_is_value = False;
         p->to.addr = NULL;
     }
-    else if (to->size <= sizeof(p->to.addr)) {
-        p->to_is_value = True;
-        XtMemmove(&p->to.addr, to->addr, to->size);
-    }
     else {
-        p->to_is_value = False;
-        p->to.addr = (XPointer) _XtHeapAlloc(heap, to->size);
-        (void) memcpy(p->to.addr, (char *) to->addr, to->size);
+       XPointer src_ptr, dest_ptr, gptr;
+
+        if ((size_t)to->size <= sizeof(p->to.addr)) {
+               p->to_is_value = True;
+                dest_ptr = (XPointer)&p->to.addr;
+        } else {
+                p->to_is_value = False;
+                dest_ptr = p->to.addr = (XPointer)_XtHeapAlloc(heap, to->size);
+        }
+
+        if (do_ref & XtCacheXmRefCount) {
+                gptr = (*(p->replicator))(*(XtPointer *)(to->addr));
+                src_ptr = (XtPointer)&gptr;
+        } else {
+                src_ptr = to->addr;
+        }
+
+        memmove(dest_ptr, src_ptr, to->size);
     }
+
+    if ((succeeded && destructor) || do_ref) {
+       p->ref_count = 1;
+    }
+
     UNLOCK_PROCESS;
     return p;
 }
 
 static void
-FreeCacheRec(XtAppContext app, CachePtr p, CachePtr * prev)
+FreeCacheRec(XtAppContext app, CachePtr p, Boolean clean_table)
 {
     LOCK_PROCESS;
-    if (p->has_ext) {
-        if (CEXT(p)->destructor) {
-            Cardinal num_args = p->num_args;
-            XrmValue *args = NULL;
-            XrmValue toc;
+    if (clean_table) {
+        CachePtr cachep, *cachepp;
+        cachepp = &cacheHashTable[p->hash & CACHEHASHMASK];
+        while (cachep = *cachepp) {
+            if (p == cachep) {
+               *cachepp = cachep->next;
+                break;
+            }
+           cachepp = &cachep->next;
+        }
+    }
 
-            if (num_args)
-                args = CARGS(p);
-            toc.size = p->to.size;
-            if (p->to_is_value)
-                toc.addr = (XPointer) &p->to.addr;
-            else
-                toc.addr = p->to.addr;
-            (*CEXT(p)->destructor) (app, &toc, CEXT(p)->closure, args,
-                                    &num_args);
+    if (p->destructor) {
+        Cardinal num_args=p->num_args;
+        XrmValue *args=NULL;
+        XrmValue toc;
+
+        if (num_args) {
+               args = CARGS(p);
+
         }
-        *(CEXT(p)->prev) = p->next;
-        if (p->next && p->next->has_ext)
-            CEXT(p->next)->prev = CEXT(p)->prev;
+        toc.size = p->to.size;
+        if (p->to_is_value) {
+                toc.addr = (XPointer)&p->to.addr;
+        } else {
+               toc.addr = p->to.addr;
+        }
+       (*p->destructor)(app, &toc, p->closure, args, &num_args);
     }
-    else if (prev) {
-        *prev = p->next;
-        if (p->next && p->next->has_ext)
-            CEXT(p->next)->prev = prev;
-    }
     if (p->must_be_freed) {
         register int i;
 
Oracle Bug 15172798 - SUNBT4907034 XtOverrideTranslations() takes 10x more
  cycles than 32-bit.

This fix is SPARC-specific and should be reworked to apply to both big- &
little-endian machines before being sent upstream.

Root cause:
64bit libXt has worse performance compared with 32bit libXt because current
libXt construct the converter hash table by using the second byte of address
member of from data structure. However, in 64bit model, most second byte are
0, which lower the hash table effeciency.

Solution:
If current application is 64bit model, use the 7th byte to hash the
converter. Moreover, add more optimization macro definition.

--- a/src/Convert.c	2022-11-07 18:38:02.582934787 -0800
+++ b/src/Convert.c	2022-11-07 18:39:37.801918875 -0800
@@ -717,9 +717,13 @@
     LOCK_PROCESS;
     /* Try to find cache entry for conversion */
     hash = HashCode(converter, from);
-    if (from->size > 1)
-        hash += ((char *) from->addr)[1];
-
+    if (from->size > 1) {
+	if (sizeof(long) == 4)
+            hash += ((char *) from->addr)[1];
+        else
+            hash += ((char *) from->addr)[6];
+    }
+        
     for (p = cacheHashTable[hash & CACHEHASHMASK]; p; p = p->next) {
         if ((p->hash == hash)
             && (p->converter == (XtTypeConverter) converter)
@@ -816,8 +820,12 @@
     LOCK_PROCESS;
     /* Try to find cache entry for conversion */
     hash = HashCode(converter, from);
-    if (from->size > 1)
-        hash += ((char *) from->addr)[1];
+    if (from->size > 1) {
+	if (sizeof(long) == 4)
+            hash += ((char *) from->addr)[1];
+        else
+            hash += ((char *) from->addr)[6];
+    }
 
     if (cP->cache_type != XtCacheNone) {
         for (p = cacheHashTable[hash & CACHEHASHMASK]; p; p = p->next) {
Oracle Bug 15143893 - SUNBT4810740 vsw512 test XtCallbackReleaseCacheRefList
    regresses in S10_26

XtCallbackReleaseCacheRefList() should not be calling XtFree(closure) as it
does not "own" this data.  In the VSW test it points to an automatic array.

Reported upstream:
https://gitlab.freedesktop.org/xorg/lib/libxt/-/issues/15

--- a/src/Convert.c	2022-11-07 19:06:55.487305676 -0800
+++ b/src/Convert.c	2022-11-07 19:07:08.318327812 -0800
@@ -1190,7 +1190,6 @@
 {
     XtAppReleaseCacheRefs(XtWidgetToApplicationContext(widget),
                           (XtCacheRef *) closure);
-    XtFree(closure);
 }
 
 void
Oracle Bug 15187627 - SUNBT4962001 There are some memory leak in motif

Root Cause:
This bug exists because function "GetResources" will return a copy of resource
to the function caller in case the caller want to check on the resource and
the caller has the responsibility to free the returned copy, however some
functions, such as "XtCreate", "XtGetSubresources", "_XtGetResources",
"XtGetSubresources", invoked "GetResources" and "XtGetApplicationResources"
without freeing the returned resource copy.

[This is only one portion of the original fix, which also modified
 Resources.c - need to determine if this is still correct and then
 either submit upstream or discard.]

Solution:
Free the returned resource copy in caller functions.

--- a/src/Create.c	2022-11-07 19:08:15.417832109 -0800
+++ b/src/Create.c	2022-11-07 19:08:57.859305884 -0800
@@ -405,8 +405,7 @@
     CompileCallbacks(widget);
 
     if (cache_refs != NULL) {
-        XtAddCallback(widget, XtNdestroyCallback,
-                      XtCallbackReleaseCacheRefList, (XtPointer) cache_refs);
+        XtFree(cache_refs);
     }
 
     wsize = widget_class->core_class.widget_size;
Oracle Bug 15028407 - SUNBT4344557 setting XmNpacking resource of XmRowColumn
   widget causes core dump

What happens is that when _XtAppInit is called it saves a backup of the
argv_in_out value passed into it.  The backup value is initially created with
space for the arguments, and one extra item so that the list may be NULL
terminated.

The argv_in_out list is then traversed and all values are copied before
finally NULL terminating the list.

At the end of the function, the argv_in_out value is in theory restored to
its original value, albeit with the contents in a new memory location(safe
from being freed by the shell or anyone else).  In this case, it has been
given a value that it didn't have in the first place.

When a NULL value is passed in to _XtAppInit, memory is allocated for one
item which is NULL.  The address of this memory is saved back to the
argv_in_out value instead of NULL.  Subsequent functions see a real value
instead of NULL and it is this value that is stored in the XtNargv resource
of the shell.  

When the value of XtNargv is retrieved it is not-null, but its value doesn't
make sense.

Need to evaluate for submission upstream.

--- a/src/Display.c	2022-11-07 19:09:53.543560261 -0800
+++ b/src/Display.c	2022-11-07 19:11:41.337732726 -0800
@@ -346,12 +346,16 @@
     /*
      * Save away argv and argc so we can set the properties later
      */
-    saved_argv = XtMallocArray((Cardinal) *argc_in_out + 1,
-                               (Cardinal) sizeof(_XtString));
+    if (*argv_in_out != NULL) {
+       saved_argv = (String *)
+               __XtMalloc( (Cardinal)((*argc_in_out + 1) * sizeof(String)) );
 
-    for (i = 0; i < *argc_in_out; i++)
-        saved_argv[i] = (*argv_in_out)[i];
-    saved_argv[i] = NULL;       /* NULL terminate that sucker. */
+    for (i = 0 ; i < *argc_in_out ; i++)
+               saved_argv[i] = (*argv_in_out)[i];
+       saved_argv[i] = NULL;   /* NULL terminate that sucker. */
+    } else {
+       saved_argv = NULL;
+    }
 
     *app_context_return = XtCreateApplicationContext();
 
Maintain Solaris ABI compatibility across X11R5 -> X11R6 upgrade.

Need to evaluate for submission upstream.

Code in Event.c checked in without a BugID:

D 1.5   96/01/19 17:37:50 stuartm       6 5     00016/00000/01844
added compatability functions _XtRegisterWindow and _XtUnregisterWindow
They simply call the newer drawable routines.

Code in NextEvent.c checked in under:

Bug 14917447 - SUNBT1254790 _XtwaitForSomething renamed in X11R6 with no backcompat

The symbol _XtwaitForSomething in X11R5 was changed to _XtWaitForSomething in
X11R6.

This violates backwards compatibility and disables all extensions which use
the symbol.

Incorporates fix for
Oracle Bug 14974628 - SUNBT4185875 _XtwaitForSomething implemented incorrectly
    on X11R6. It does not work.

which added the missing "return" keywords.

--- a/src/Event.c	2022-11-07 19:12:33.474188705 -0800
+++ b/src/Event.c	2022-11-07 19:13:39.893732706 -0800
@@ -590,6 +590,14 @@
     UNLOCK_APP(app);
 }
 
+/* need this for backward compatability */
+void _XtRegisterWindow(
+    Window window,
+    Widget widget)
+{
+    XtRegisterDrawable(XtDisplay(widget), (Drawable)window, widget);
+}
+
 void
 XtUnregisterDrawable(Display *display, Drawable drawable)
 {
@@ -641,6 +649,14 @@
     UNLOCK_APP(app);
 }
 
+/* need this for backward compatability */
+void _XtUnregisterWindow(
+    register Window window,
+    register Widget widget)
+{
+    XtUnregisterDrawable(XtDisplay(widget), (Drawable)window);
+}
+
 static void
 ExpandWWTable(register WWTable tab)
 {
--- a/src/NextEvent.c	2022-11-07 19:13:50.529610200 -0800
+++ b/src/NextEvent.c	2022-11-07 19:14:35.844822484 -0800
@@ -782,6 +782,33 @@
 #define SeCallProc(ptr) \
     (*ptr->se_proc) (ptr->se_closure, (XtSignalId*)&ptr);
 
+#ifdef sun /*SUNSOFT */
+int _XtwaitForSomething(
+    _XtBoolean ignoreTimers,
+    _XtBoolean ignoreInputs,
+    _XtBoolean ignoreEvents,
+    _XtBoolean block,
+    unsigned long *howlong,
+    XtAppContext app)
+{
+#ifdef XTHREADS
+/* fix for bug 4185875 leob */
+return _XtWaitForSomething(app,
+            ignoreEvents, ignoreTimers, ignoreInputs, TRUE,
+            block,
+            TRUE,
+            howlong);
+#else
+/* fix for bug 4185875 leob */
+return _XtWaitForSomething(app,
+            ignoreEvents, ignoreTimers, ignoreInputs, TRUE,
+            block,
+            howlong);
+#endif
+
+}
+#endif /* SUNSOFT */
+
 /*
  * Public Routines
  */
Oracle Bug 14965635 - SUNBT4153816 XtMakeResizeRequest() should return
    XtGeometryYes not XtGeometryDone

Need to evaluate for submission upstream.

This bug was found during VSW5 testing ( Testcase: XtMakeResizeRequest
  Purpose:  9)

The test description is:

Assertion XtMakeResizeRequest-9.(A)
A call to XtGeometryResult XtMakeResizeRequest(w, width,
height, width_return, height_return) when the widget w is
realized, the width field of the widget is not equal to
width or the height field is not equal to height, and the
call to the geometry_manager procedure of the widget's
parent returns XtGeometryDone shall return XtGeometryYes.


Under the conditions described above, XtMakeResizeRequest() returns
XtGeometryDone instead of XtGeometryYes. 

--- a/src/Geometry.c	2022-11-07 19:15:26.274225985 -0800
+++ b/src/Geometry.c	2022-11-07 19:16:12.473217747 -0800
@@ -336,6 +336,11 @@
         else {
             returnCode = (*manager) (widget, request, reply);
         }
+       /* leob fix for bug 4153816 */
+        if (returnCode == XtGeometryDone && XtIsRealized(widget) &&
+            (widget->core.width != request->width ||
+             widget->core.height != request->height) )
+            return XtGeometryYes;
     }
 
     /*
Oracle Bug 14921397 - SUNBT1264008 Resource file ignored when XtSetLanguageProc
    called

When LANG=en_US, even when LC_NUMERIC=C, an application should look at its
resources file in XAPPLRESDIR/%L, with %L=LANG=en_US.

Here, when LC_NUMERIC=C, it looks in XAPPLRESDIR (it ignores %L). 

Need to evaluate for submission upstream.

--- a/src/Initialize.c	2022-11-07 19:16:54.921319439 -0800
+++ b/src/Initialize.c	2022-11-07 19:17:14.904036584 -0800
@@ -487,7 +487,7 @@
     if (!XSetLocaleModifiers(""))
         XtWarning("X locale modifiers not supported, using default");
 
-    return setlocale(LC_ALL, NULL);     /* re-query in case overwritten */
+    return setlocale(LC_CTYPE, NULL); /* re-query in case overwritten */
 }
 
 XtLanguageProc
Oracle Bug 14965260 - SUNBT4152296 REGRESSION: setting XmNpacking resource of
    XmRowColumn widget causes core dump

The reason we are getting a core is that freed memeory is being accessed.
XmNargv (RCLayout.c) resource has been freed but this only occurs when using
dtksh.

The problem arises when XtInitialize is passed 0 as argc, and argv value of
NULL, the XmNargv resource is being set to invalid address.

Do a check in the XtOpenApplication function (Initialize.c) for a valid
argv before setting XtNargv resource.

Need to evaluate for submission upstream.

--- a/src/Initialize.c	2022-11-07 19:18:10.104481416 -0800
+++ b/src/Initialize.c	2022-11-07 19:18:57.904521930 -0800
@@ -1025,11 +1025,15 @@
     LOCK_APP(app_con);
     XtSetArg(args[num], XtNscreen, DefaultScreenOfDisplay(dpy));
     num++;
-    XtSetArg(args[num], XtNargc, saved_argc);
-    num++;
-    XtSetArg(args[num], XtNargv, argv_in_out);
-    num++;
 
+    /* only set argc and argv if argv_in_out[0] is not NULL */
+    if (argv_in_out && argv_in_out[0]) {
+       XtSetArg(args[num], XtNargc, saved_argc);
+       num++;
+       XtSetArg(args[num], XtNargv, argv_in_out);
+       num++;
+    }
+
     merged_args = XtMergeArgLists(args_in, num_args_in, args, num);
     num += num_args_in;
 
Oracle Bug 14961740 - SUNBT4136406 dtgreet runs wild and error messages
    fill /var/dt/Xerrors
Oracle Bug 15072668 - SUNBT4482749 Xt spins forever when select() returns EBADF

Changed handling of select() error to not retry indefinitely.

Description of 14961740:
When select() returns EINVAL, investigate whether this condition is caused by an
invalid timeout value, or whether one of the fds in the fd_set is invalid. If
the problem is caused by the timeout value, then the problem can be cured by
adjusting these. If the problem arises because of the fd_set, then Xt can do
little better than to terminate the application, since it has no direct way of
curing the condition.

Description of 15072668:
_XtWaitForSomething did not explicity check for EBADF.  This caused the function
to continuously call select for the bad file descriptor leading to an infinite
loop.

Added in an error handler for this particular error.

In the event of an EBADF, the Xt removes all Input Procedures that monitor the
offending file descriptor.  This prevents it from repeating checks which are
going to fail.

Additionally, an XtWarning is issued to the user.  An XtError is too much as
it will dump the user out of the program.

Finally, the error handler returns -1 from _XtWaitForSomething().


Need to evaluate for submission upstream.

--- a/configure.ac	2022-11-07 19:20:45.189568737 -0800
+++ b/configure.ac	2022-11-07 19:21:07.279113999 -0800
@@ -80,6 +80,7 @@
 
 # Map function checks to old Imake #defines
 case $host_os in
+	solaris*) ;; # our changes to NextEvent.c break if poll() is used
 	# darwin through Snow Leopard has poll() but can't be used to poll character devices.
 	darwin@<:@789@:>@*|darwin10*) ;;
 	darwin*)
--- a/src/NextEvent.c	2022-11-07 19:21:23.489203221 -0800
+++ b/src/NextEvent.c	2022-11-07 19:29:41.331516786 -0800
@@ -367,6 +367,53 @@
     }
 }
 
+static void CheckAndTrimTimes(XtAppContext app, wait_times_ptr_t wt)
+{
+   struct timeval tv;
+   String         pptrs[8];
+   Cardinal       nbr_parms;
+
+   pptrs[0] = (String)zero_time.tv_sec;
+   pptrs[1] = (String)zero_time.tv_usec;
+   pptrs[2] = (String)wt->wait_time.tv_sec;
+   pptrs[3] = (String)wt->wait_time.tv_usec;
+   pptrs[4] = (String)wt->max_wait_time.tv_sec;
+   pptrs[5] = (String)wt->max_wait_time.tv_usec;
+   pptrs[6] = (String)wt->cur_time.tv_sec;
+   pptrs[7] = (String)wt->cur_time.tv_usec;
+   nbr_parms = 8;
+   XtAppErrorMsg(app, "communicationError", "select",
+                 XtCXtToolkitError, "Resetting timer values: zero_time=%lu:%lu, "
+                 "wait_time=%lu:%lu, max_wait_time=%lu:%lu, cur_time=%lu:%lu",
+                 pptrs, &nbr_parms);
+
+   memset(&zero_time, 0, sizeof(zero_time)); /* Ensure the integrity of       */
+                                             /* zero_time.                    */
+   if (wt->max_wait_time.tv_sec > 99999999)  /* Bring max_wait_time back into */
+    {                                        /* acceptable range if nec.      */
+      wt->max_wait_time.tv_sec &= 0xFFFFF;
+      wt->max_wait_time.tv_usec = 0;         /* (Fractions of a sec are in-   */
+                                             /*  significant at this level.)  */
+    }
+   if (app->timerQueue != NULL)              /* Do the same for the head of   */
+    {                                        /* the timer queue if necessary. */
+      TIMEDELTA(tv, app->timerQueue->te_timer_value, wt->cur_time);
+      if (tv.tv_sec > 99999999)
+       {
+         pptrs[0] = (String)app->timerQueue->te_timer_value.tv_sec;
+         pptrs[1] = (String)app->timerQueue->te_timer_value.tv_usec;
+         nbr_parms = 2;
+         XtAppErrorMsg(app, "selectError", "timerQueue",
+                       XtCXtToolkitError, "timerQueue value %lu:%lu is invalid",
+                       pptrs, &nbr_parms);
+         tv.tv_sec &= 0xFFFFF;
+         tv.tv_usec = 0;
+         ADD_TIME(app->timerQueue->te_timer_value, wt->cur_time, tv);
+       }
+    }
+}
+
+
 static int
 IoWait(wait_times_ptr_t wt, wait_fds_ptr_t wf)
 {
@@ -717,17 +799,32 @@
                         nfds = 0;
                 }
             }
-            else {
-                char Errno[12];
-                String param = Errno;
-                Cardinal param_count = 1;
+            else if (errno == EINVAL) {
+                struct timeval  tv={0};
 
-                sprintf(Errno, "%d", errno);
-                XtAppWarningMsg(app, "communicationError", "select",
-                                XtCXtToolkitError,
-                                "Select failed; error code %s", &param,
-                                &param_count);
-                continue;
+                nfds = Select(wf.nfds, &wf.rmask, &wf.wmask, &wf.emask, &tv);
+                                                /* Do a non-blocking select to  */
+                                                /* eliminate any timeout errors.*/
+                if (nfds == -1) {               /* Now try to sort out the good */
+                    if (errno == EINVAL) {      /* and the bad from the ugly.   */
+                        char    Errno[12];      /* (This is ugly).              */
+                        String  param = Errno;
+                        Cardinal param_count = 1;
+
+                        sprintf(Errno, "%d", errno);
+                        XtAppErrorMsg(app, "communicationError", "select",
+                                      XtCXtToolkitError, "Select failed; error code %s",
+                                      &param, &param_count);
+                        XtAppError(app, "EINVAL error in select() call");
+                    } else {                    /* If the new error is not about */
+                                                /* an invalid select() parameter,*/
+                        continue;               /* then simply try again.        */
+                    }
+                } else {                        /* (Else the error appears to be */
+                                                /* in the timeout parameter.)    */
+                    CheckAndTrimTimes(app, &wt);
+                    continue;
+                }
             }
         }                       /* timed out or input available */
         break;
--- a/src/NextEvent.c	2024-08-23 17:16:20.202048925 -0700
+++ b/src/NextEvent.c	2024-08-23 17:19:37.616146755 -0700
@@ -696,13 +696,48 @@
             /*
              *  interrupt occurred recalculate time value and wait again.
              */
-            if (errno == EINTR || errno == EAGAIN) {
-                if (errno == EAGAIN) {
+            if (errno == EAGAIN) {
                     errno = 0;  /* errno is not self resetting */
                     continue;
-                }
-                errno = 0;      /* errno is not self resetting */
+            } else if (errno == EBADF) {
+                /* Bug 4482749 - If we have a bad FD stop monitoring it */
+                int i;
+                struct timeval tv={0};
+                for (i = 0; i < wf.nfds; i++) {
+                    if (FD_ISSET(i, &wf.rmask) || FD_ISSET(i, &wf.wmask) ||
+                          FD_ISSET(i, &wf.emask)) {
+                        if (select(i + 1, &wf.rmask, &wf.wmask, &wf.emask, &tv)
+                              == -1) {
+                            char     bad_fd[55];
+                            String   param = bad_fd;
+                            Cardinal param_count = 1;
+                            /*
+                             * Get rid of any input procedures on the bad FD
+                             * and regenerate the list of FDs we listen to.
+                             */
+                            while (app->input_list[i] != NULL) {
+                              XtRemoveInput((XtInputId)app->input_list[i]);
+                            }
+                            InitFds (app, ignoreEvents, ignoreInputs, &wf);
 
+                            sprintf(bad_fd, "%d", errno);
+                            XtAppWarningMsg(app, "communicationError", "select",
+                                            XtCXtToolkitError,
+                                            "Select failed; error code %s",
+                                            &param, &param_count);
+
+                            sprintf(bad_fd, "EBADF error in select() call for file descriptor %d", i);
+                            XtAppWarning(app, param);
+
+                          }
+                      }
+                  }
+
+                return -1;
+
+                } else if (errno == EINTR) {
+                           errno = 0;      /* errno is not self reseting */
+
                 /* was it interrupted by a signal that we care about? */
                 if (!ignoreSignals && app->signalQueue != NULL) {
                     SignalEventRec *se_ptr = app->signalQueue;
@@ -710,7 +745,7 @@
                     while (se_ptr != NULL) {
                         if (se_ptr->se_notice) {
                             if (block && howlong != NULL)
-                                AdjustHowLong(howlong, &wt.start_time);
+                                AdjustHowLong (howlong, &wt.start_time);
 #ifdef USE_POLL
                             XtStackFree((XtPointer) wf.fdlist, fdlist);
 #endif
Fix mismatched paren

https://gitlab.freedesktop.org/xorg/lib/libxt/-/merge_requests/72

--- a/include/X11/Xtos.h	2024-12-29 15:47:39.958280318 -0800
+++ b/include/X11/Xtos.h	2024-12-29 15:47:51.218234383 -0800
@@ -64,7 +64,7 @@
     defined(__s390x__) || \
     (defined(__hppa__) && defined(__LP64__)) || \
     defined(__amd64__) || defined(amd64) || \
-    defined(__powerpc64__))
+    defined(__powerpc64__)
 #define LONG64
 #endif
 
